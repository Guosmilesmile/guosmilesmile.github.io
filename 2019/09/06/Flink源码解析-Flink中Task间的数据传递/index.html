<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="数据传递AbstractStreamOperator$CountingOutput.collect123456@Override		public void collect(StreamRecord&amp;lt;OUT&amp;gt; record) &amp;#123;			numRecordsOut.inc();			output.collect(record);		&amp;#125; 同一个TM和同一线程的Operat">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink源码解析 Flink中Task间的数据传递">
<meta property="og:url" content="http://yoursite.com/2019/09/06/Flink源码解析-Flink中Task间的数据传递/index.html">
<meta property="og:site_name" content="Pray">
<meta property="og:description" content="数据传递AbstractStreamOperator$CountingOutput.collect123456@Override		public void collect(StreamRecord&amp;lt;OUT&amp;gt; record) &amp;#123;			numRecordsOut.inc();			output.collect(record);		&amp;#125; 同一个TM和同一线程的Operat">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/482B071BB9574F26A49F8B2C8245A085?method=download&shareKey=f91aa5fda263f74e7a6b199c5464f1a6">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/D74FFBA07746402CA2672A42DB3FF925?method=download&shareKey=d730d08090d92224cf968549b0d84837">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/DEC307A65DCB4008BF401E5C0EDEA534?method=download&shareKey=2e30476f270cad20ad2cedb16a00a4c3">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/07BDD946C3E14C7DAD55C7438696A1E9?method=download&shareKey=c040cef54a82640144867cea05aa76bd">
<meta property="og:updated_time" content="2019-09-07T04:36:32.525Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Flink源码解析 Flink中Task间的数据传递">
<meta name="twitter:description" content="数据传递AbstractStreamOperator$CountingOutput.collect123456@Override		public void collect(StreamRecord&amp;lt;OUT&amp;gt; record) &amp;#123;			numRecordsOut.inc();			output.collect(record);		&amp;#125; 同一个TM和同一线程的Operat">
<meta name="twitter:image" content="https://note.youdao.com/yws/api/personal/file/482B071BB9574F26A49F8B2C8245A085?method=download&shareKey=f91aa5fda263f74e7a6b199c5464f1a6">






  <link rel="canonical" href="http://yoursite.com/2019/09/06/Flink源码解析-Flink中Task间的数据传递/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Flink源码解析 Flink中Task间的数据传递 | Pray</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pray</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">人肉排渣工程师,擅长排渣数据，服务器排渣</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/06/Flink源码解析-Flink中Task间的数据传递/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="笑笑">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://note.youdao.com/yws/api/personal/file/85E1A31B078749AAA5FBFA9FF57A0FCB?method=download&shareKey=312d566957926c021bfd2bf29d0fb19c#/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pray">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Flink源码解析 Flink中Task间的数据传递

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-06 23:12:05" itemprop="dateCreated datePublished" datetime="2019-09-06T23:12:05+08:00">2019-09-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-07 12:36:32" itemprop="dateModified" datetime="2019-09-07T12:36:32+08:00">2019-09-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Flink/" itemprop="url" rel="index"><span itemprop="name">Flink</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://note.youdao.com/yws/api/personal/file/482B071BB9574F26A49F8B2C8245A085?method=download&amp;shareKey=f91aa5fda263f74e7a6b199c5464f1a6" alt="image"></p>
<h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>AbstractStreamOperator$CountingOutput.collect<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(StreamRecord&lt;OUT&gt; record)</span> </span>&#123;</span><br><span class="line">			numRecordsOut.inc();</span><br><span class="line">			output.collect(record);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>同一个TM和同一线程的Operator的区分在这里。如果是同一个TM</p>
<p>用到的是RecordWriterOutput.collect，如果是同一个线程的operator，用到的是OperatorChain$CopyingChainingOutput.collect</p>
<h3 id="同一线程的Operator数据传递-同一个Task"><a href="#同一线程的Operator数据传递-同一个Task" class="headerlink" title="同一线程的Operator数据传递(同一个Task)"></a>同一线程的Operator数据传递(同一个Task)</h3><p><img src="https://note.youdao.com/yws/api/personal/file/D74FFBA07746402CA2672A42DB3FF925?method=download&amp;shareKey=d730d08090d92224cf968549b0d84837" alt="image"></p>
<p>allOperators中有算子和out的关系，在调用out（CopyingChainingOutput）的时候，会调用pushToOperator函数，这个函数内部会通过深拷贝复制出一个实体，在这个out中，存在一个属性，这个属性是下游的function，然后调用function函数进行计算并继续out出去。</p>
<h5 id="构建operation-chain"><a href="#构建operation-chain" class="headerlink" title="构建operation  chain"></a>构建operation  chain</h5><p>这个过程就是将整个operation chain构建出来，然后将CopyingChainingOutput中注入下游operation，形成当前operation包含CopyingChainingOutput，CopyingChainingOutput中有下游的operation。</p>
<p>实现数据从上游处理后，调用out.collect可以直接传递给下游的operation。</p>
<p>operatorChain = new OperatorChain&lt;&gt;(this, recordWriters);获取这个task的整个操作链和headOperator,初始化output.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OperatorChain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			StreamTask&lt;OUT, OP&gt; containingTask,</span></span></span><br><span class="line"><span class="function"><span class="params">			List&lt;RecordWriter&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt;&gt; recordWriters)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>重点函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">//	创建操作链，并且将 设置链的leads</span></span><br><span class="line"><span class="comment">// we create the chain of operators and grab the collector that leads into the chain</span></span><br><span class="line"><span class="keyword">this</span>.chainEntryPoint = createOutputCollector(</span><br><span class="line">	containingTask,</span><br><span class="line">	configuration,</span><br><span class="line">	chainedConfigs,</span><br><span class="line">	userCodeClassloader,</span><br><span class="line">	streamOutputMap,</span><br><span class="line">	allOps);</span><br></pre></td></tr></table></figure>
<p>OperatorChain<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;IN, OUT&gt; WatermarkGaugeExposingOutput&lt;StreamRecord&lt;IN&gt;&gt; createChainedOperator(</span><br><span class="line">			StreamTask&lt;?, ?&gt; containingTask,</span><br><span class="line">			StreamConfig operatorConfig,</span><br><span class="line">			Map&lt;Integer, StreamConfig&gt; chainedConfigs,</span><br><span class="line">			ClassLoader userCodeClassloader,</span><br><span class="line">			Map&lt;StreamEdge, RecordWriterOutput&lt;?&gt;&gt; streamOutputs,</span><br><span class="line">			List&lt;StreamOperator&lt;?&gt;&gt; allOperators,</span><br><span class="line">			OutputTag&lt;IN&gt; outputTag) &#123;</span><br></pre></td></tr></table></figure></p>
<p>先获取同一个操作链中head的outputEdge，先通过递归的方式，创建每个operation对应的output，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">WatermarkGaugeExposingOutput&lt;StreamRecord&lt;OUT&gt;&gt; chainedOperatorOutput = createOutputCollector(</span><br><span class="line">			containingTask,</span><br><span class="line">			operatorConfig,</span><br><span class="line">			chainedConfigs,</span><br><span class="line">			userCodeClassloader,</span><br><span class="line">			streamOutputs,</span><br><span class="line">			allOperators);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取对应的流式操作符</span></span><br><span class="line">		<span class="comment">// now create the operator and give it the output collector to write its output to</span></span><br><span class="line">		OneInputStreamOperator&lt;IN, OUT&gt; chainedOperator = operatorConfig.getStreamOperator(userCodeClassloader);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将操作函数和out组成chainedOperator加入allOperators</span></span><br><span class="line">		chainedOperator.setup(containingTask, operatorConfig, chainedOperatorOutput);</span><br><span class="line"></span><br><span class="line">		allOperators.add(chainedOperator);</span><br></pre></td></tr></table></figure>
<p>然后将操作函数和out组成chainedOperator加入allOperators.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentOperatorOutput = <span class="keyword">new</span> CopyingChainingOutput&lt;&gt;(chainedOperator, inSerializer, outputTag, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>通过如上方法，将chainedOperator（下一个operation）和CopyingChainingOutput绑定在一起，调用和CopyingChainingOutput的collect方法可以直接调用operation.processElements实现内部调用。。</p>
<h4 id="同一个线程的Operator中数据的复制"><a href="#同一个线程的Operator中数据的复制" class="headerlink" title="同一个线程的Operator中数据的复制"></a>同一个线程的Operator中数据的复制</h4><p>OperatorChain<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StreamRecord&lt;T&gt; copy = castRecord.copy(serializer.copy(castRecord.getValue())); 数据复制</span><br><span class="line">operator.processElement(copy);</span><br></pre></td></tr></table></figure></p>
<p>serializer会有多种类型，StringSerializer、TupleSerializer、PojoSerializer等等，String这种类型，copy方法会就是直接返回，对于Tuple、Pojo，Tuple会创建一个Tuple，将原来的数据set到新的Tuple中，如果是Pojo，会通过反射，<br>先将所有的属性设置为可以访问，屏蔽掉private的影响<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.fields[i].setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>然后根据字段对应的类型用对应的序列化器深度copy一个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         Object value = fields[i].get(from);</span><br><span class="line"><span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object copy = fieldSerializers[i].copy(value);</span><br><span class="line">		fields[i].set(target, copy);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fields[i].set(target, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="本地线程数据传递-同一个TM"><a href="#本地线程数据传递-同一个TM" class="headerlink" title="本地线程数据传递(同一个TM)"></a>本地线程数据传递(同一个TM)</h3><p>如果并行度一致，并且是forward，会被归在同一个operationChain，走上面的情况，如果不是，则会归属在不同的task中。不同task会出现两种情况，一种是task归属于同一个TM，一种是task归属于不同TM</p>
<p>不同个TM通过RecordWriter来发送数据到下游。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[RecordWriter]--包含--&gt;B[ResultPartitionWriter]</span><br></pre></td></tr></table></figure>
<h4 id="RecordWriter初始化"><a href="#RecordWriter初始化" class="headerlink" title="RecordWriter初始化"></a>RecordWriter初始化</h4><p>在StreamTask.createRecordWriters. 某一个顶点，以后多个输出那么List<streamedge> outEdgesInOrder会是n，如果只有一条支流，那么就是1.</streamedge></p>
<p>RecordWriter的初始化是在Task创建StreamTask的时候调用如下构建的</p>
<p>Task.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass, env);</span><br></pre></td></tr></table></figure></p>
<p>StreamTask.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;OUT&gt; List&lt;RecordWriter&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt;&gt; createRecordWriters(</span><br><span class="line">			StreamConfig configuration,</span><br><span class="line">			Environment environment) &#123;</span><br><span class="line">		List&lt;RecordWriter&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt;&gt; recordWriters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;StreamEdge&gt; outEdgesInOrder = configuration.getOutEdgesInOrder(environment.getUserClassLoader());</span><br><span class="line">		Map&lt;Integer, StreamConfig&gt; chainedConfigs = configuration.getTransitiveChainedTaskConfigsWithSelf(environment.getUserClassLoader());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outEdgesInOrder.size(); i++) &#123;</span><br><span class="line">			StreamEdge edge = outEdgesInOrder.get(i);</span><br><span class="line">			recordWriters.add(</span><br><span class="line">				createRecordWriter(</span><br><span class="line">					edge,</span><br><span class="line">					i,</span><br><span class="line">					environment,</span><br><span class="line">					environment.getTaskInfo().getTaskName(),</span><br><span class="line">					chainedConfigs.get(edge.getSourceId()).getBufferTimeout()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> recordWriters;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果下游有一个，就创建一RecordWriter，如果下游有两个（重复消费），就创建两个RecordWriter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;OUT&gt; RecordWriter&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt; createRecordWriter(</span><br><span class="line">		StreamEdge edge,</span><br><span class="line">		<span class="keyword">int</span> outputIndex,</span><br><span class="line">		Environment environment,</span><br><span class="line">		String taskName,</span><br><span class="line">		<span class="keyword">long</span> bufferTimeout) &#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	StreamPartitioner&lt;OUT&gt; outputPartitioner = (StreamPartitioner&lt;OUT&gt;) edge.getPartitioner();</span><br><span class="line"></span><br><span class="line">	LOG.debug(<span class="string">"Using partitioner &#123;&#125; for output &#123;&#125; of task &#123;&#125;"</span>, outputPartitioner, outputIndex, taskName);</span><br><span class="line"></span><br><span class="line">	ResultPartitionWriter bufferWriter = environment.getWriter(outputIndex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we initialize the partitioner here with the number of key groups (aka max. parallelism)</span></span><br><span class="line">	<span class="keyword">if</span> (outputPartitioner <span class="keyword">instanceof</span> ConfigurableStreamPartitioner) &#123;</span><br><span class="line">		<span class="keyword">int</span> numKeyGroups = bufferWriter.getNumTargetKeyGroups();</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> &lt; numKeyGroups) &#123;</span><br><span class="line">			((ConfigurableStreamPartitioner) outputPartitioner).configure(numKeyGroups);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RecordWriter&lt;SerializationDelegate&lt;StreamRecord&lt;OUT&gt;&gt;&gt; output =</span><br><span class="line">		RecordWriter.createRecordWriter(bufferWriter, outputPartitioner, bufferTimeout, taskName);</span><br><span class="line">	output.setMetricGroup(environment.getMetricGroup().getIOMetricGroup());</span><br><span class="line">	<span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点在于如下代码，可以构建出下游有多少消费者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultPartitionWriter bufferWriter = environment.getWriter(outputIndex);</span><br></pre></td></tr></table></figure></p>
<p>environment的Writer是对应到Task中的producedPartitions，producedPartitions的初始化是在Task初始化的时候.</p>
<p>Task.java的构造函数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Produced intermediate result partitions</span></span><br><span class="line">		<span class="keyword">this</span>.producedPartitions = <span class="keyword">new</span> ResultPartition[resultPartitionDeploymentDescriptors.size()];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (ResultPartitionDeploymentDescriptor desc: resultPartitionDeploymentDescriptors) &#123;</span><br><span class="line">			ResultPartitionID partitionId = <span class="keyword">new</span> ResultPartitionID(desc.getPartitionId(), executionId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.producedPartitions[counter] = <span class="keyword">new</span> ResultPartition(</span><br><span class="line">				taskNameWithSubtaskAndId,</span><br><span class="line">				<span class="keyword">this</span>,</span><br><span class="line">				jobId,</span><br><span class="line">				partitionId,</span><br><span class="line">				desc.getPartitionType(),</span><br><span class="line">				desc.getNumberOfSubpartitions(),</span><br><span class="line">				desc.getMaxParallelism(),</span><br><span class="line">				networkEnvironment.getResultPartitionManager(),</span><br><span class="line">				resultPartitionConsumableNotifier,</span><br><span class="line">				ioManager,</span><br><span class="line">				desc.sendScheduleOrUpdateConsumersMessage());</span><br><span class="line"></span><br><span class="line">			++counter;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是同一个operationChain中，resultPartitionDeploymentDescriptors为0，如果是出现不同个task的情况，resultPartitionDeploymentDescriptors会是下游的个数（source(1并行度)—&gt;map(3并行度)会有一个resultPartitionDeploymentDescriptors会是下游操作类型的个数）</p>
<p>这个时候就初始化好了ResultPartition，如果下游的并行度为3，那么该数组为3，对应三个ResultPartition。</p>
<h4 id="resultPartitionDeploymentDescriptors怎么来的？"><a href="#resultPartitionDeploymentDescriptors怎么来的？" class="headerlink" title="resultPartitionDeploymentDescriptors怎么来的？"></a>resultPartitionDeploymentDescriptors怎么来的？</h4><p>resultPartitionDeploymentDescriptors是TaskDeploymenentDescriptor的一部分信息，TaskDeploymenentDescriptor包含了部署一个task在一个taskManger中的所有信息。</p>
<h4 id="RecordWriter传递数据"><a href="#RecordWriter传递数据" class="headerlink" title="RecordWriter传递数据"></a>RecordWriter传递数据</h4><p>RecordWriterOutput.collect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(StreamRecord&lt;OUT&gt; record)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.outputTag != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// we are only responsible for emitting to the main input</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pushToRecordWriter(record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">pushToRecordWriter</span><span class="params">(StreamRecord&lt;X&gt; record)</span> </span>&#123;</span><br><span class="line">	serializationDelegate.setInstance(record);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		recordWriter.emit(serializationDelegate);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RecordWriter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emit</span><span class="params">(T record)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">	checkErroneous();</span><br><span class="line">	emit(record, channelSelector.selectChannel(record));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emit</span><span class="params">(T record, <span class="keyword">int</span> targetChannel)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">	serializer.serializeRecord(record);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copyFromSerializerToTargetChannel(targetChannel)) &#123;</span><br><span class="line">		serializer.prune();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>copyFromSerializerToTargetChannel这个会将数据发到resultSubpartition,传递到buffer中，再针对是否是本地数据进行操作，如果是不同TM，就会通过rpc发送，如果是同一个TM，会放在IG中，通知下游来获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializer.serializeRecord(record);</span><br></pre></td></tr></table></figure>
<p>数据序列化会调用SerializationDelegate.write,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutputView out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.serializer.serialize(<span class="keyword">this</span>.instance, out);</span><br><span class="line">	&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>实际调用了StreamElementSerializer.serialize</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(StreamElement value, DataOutputView target)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (value.isRecord()) &#123;</span><br><span class="line">			StreamRecord&lt;T&gt; record = value.asRecord();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (record.hasTimestamp()) &#123;</span><br><span class="line">				target.write(TAG_REC_WITH_TIMESTAMP);</span><br><span class="line">				target.writeLong(record.getTimestamp());</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				target.write(TAG_REC_WITHOUT_TIMESTAMP);</span><br><span class="line">			&#125;</span><br><span class="line">			typeSerializer.serialize(record.getValue(), target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value.isWatermark()) &#123;</span><br><span class="line">			target.write(TAG_WATERMARK);</span><br><span class="line">			target.writeLong(value.asWatermark().getTimestamp());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value.isStreamStatus()) &#123;</span><br><span class="line">			target.write(TAG_STREAM_STATUS);</span><br><span class="line">			target.writeInt(value.asStreamStatus().getStatus());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value.isLatencyMarker()) &#123;</span><br><span class="line">			target.write(TAG_LATENCY_MARKER);</span><br><span class="line">			target.writeLong(value.asLatencyMarker().getMarkedTime());</span><br><span class="line">			target.writeLong(value.asLatencyMarker().getOperatorId().getLowerPart());</span><br><span class="line">			target.writeLong(value.asLatencyMarker().getOperatorId().getUpperPart());</span><br><span class="line">			target.writeInt(value.asLatencyMarker().getSubtaskIndex());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>针对数据还是waterMark或者其他状态数据进行处理。如果是数据，先判断数据是否有时间，调用这个数据对应类型的序列化器（TupleSerializer）的serialize方法，将数据写成buffer转成DataOutputView实体吗，变成序列化数据.</p>
<p>然后在RecordWriteer.java中的emit方法调用copyFromSerializerToTargetChannel将序列化的数据发送出去<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emit</span><span class="params">(T record, <span class="keyword">int</span> targetChannel)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		serializer.serializeRecord(record);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copyFromSerializerToTargetChannel(targetChannel)) &#123;</span><br><span class="line">			serializer.prune();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>将序列化数据写到buffer中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">copyFromSerializerToTargetChannel</span><span class="params">(<span class="keyword">int</span> targetChannel)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// We should reset the initial position of the intermediate serialization buffer before</span></span><br><span class="line">		<span class="comment">// copying, so the serialization results can be copied to multiple target buffers.</span></span><br><span class="line">		serializer.reset();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> pruneTriggered = <span class="keyword">false</span>;</span><br><span class="line">		BufferBuilder bufferBuilder = getBufferBuilder(targetChannel);</span><br><span class="line">		SerializationResult result = serializer.copyToBufferBuilder(bufferBuilder);</span><br><span class="line">		<span class="keyword">while</span> (result.isFullBuffer()) &#123;</span><br><span class="line">			numBytesOut.inc(bufferBuilder.finish());</span><br><span class="line">			numBuffersOut.inc();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If this was a full record, we are done. Not breaking out of the loop at this point</span></span><br><span class="line">			<span class="comment">// will lead to another buffer request before breaking out (that would not be a</span></span><br><span class="line">			<span class="comment">// problem per se, but it can lead to stalls in the pipeline).</span></span><br><span class="line">			<span class="keyword">if</span> (result.isFullRecord()) &#123;</span><br><span class="line">				pruneTriggered = <span class="keyword">true</span>;</span><br><span class="line">				bufferBuilders[targetChannel] = Optional.empty();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			bufferBuilder = requestNewBufferBuilder(targetChannel);</span><br><span class="line">			result = serializer.copyToBufferBuilder(bufferBuilder);</span><br><span class="line">		&#125;</span><br><span class="line">		checkState(!serializer.hasSerializedData(), <span class="string">"All data should be written at once"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flushAlways) &#123;</span><br><span class="line">			targetPartition.flush(targetChannel);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pruneTriggered;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/DEC307A65DCB4008BF401E5C0EDEA534?method=download&amp;shareKey=2e30476f270cad20ad2cedb16a00a4c3" alt="image"></p>
<p>下游OneInputStreamTask.run()会通过死循环一直获取数据来消费<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (running &amp;&amp; inputProcessor.processInput()) &#123;</span><br><span class="line">			<span class="comment">// all the work happens in the "processInput" method</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>inputProcessor对应的是StreamInputProcessor，中间有一个变量为inputGate.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码会从buffer中逆序列化成具体的数据，然后交给userfunction处理..</p>
<p>buffer的获取，是通过如下先获取buffer，再将buffer放入currentRecordDeserializer，调用上面的currentRecordDeserializer.getNextRecord(deserializationDelegate);将buffer中解析到的数据逆序列化成deserializationDelegate。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</span><br></pre></td></tr></table></figure>
<h4 id="如何从上游中获取buffer"><a href="#如何从上游中获取buffer" class="headerlink" title="如何从上游中获取buffer"></a>如何从上游中获取buffer</h4><p>StreamInputProcessor<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();</span><br></pre></td></tr></table></figure></p>
<p>实际调用BarrierTrack.getNextNonBlocked()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;BufferOrEvent&gt; next = inputGate.getNextBufferOrEvent();</span><br></pre></td></tr></table></figure>
<p>SingleInputGate<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Optional&lt;BufferOrEvent&gt; <span class="title">getNextBufferOrEvent</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getNextBufferOrEvent(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Optional&lt;BufferOrEvent&gt; <span class="title">getNextBufferOrEvent</span><span class="params">(<span class="keyword">boolean</span> blocking)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">················</span><br><span class="line">		<span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">			inputChannelsWithData.wait();</span><br><span class="line">		&#125;</span><br><span class="line">					</span><br><span class="line"></span><br><span class="line">·····················	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个地方会wait，等待上游的ResultSubpartition去notify</p>
<h3 id="远程线程数据传递-不同TM"><a href="#远程线程数据传递-不同TM" class="headerlink" title="远程线程数据传递(不同TM)"></a>远程线程数据传递(不同TM)</h3><p><img src="https://note.youdao.com/yws/api/personal/file/07BDD946C3E14C7DAD55C7438696A1E9?method=download&amp;shareKey=c040cef54a82640144867cea05aa76bd" alt="image"></p>
<p>与同一个TM不一样的地方在于SingleInputGate中的InputChannel，<br>同一个TM用的是LocalInputChannel，不同TM用的是RemoteInputChannel.</p>
<p>RemoteInputCahnnel获取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function">Optional&lt;BufferAndAvailability&gt; <span class="title">getNextBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		checkState(!isReleased.get(), <span class="string">"Queried for a buffer after channel has been closed."</span>);</span><br><span class="line">		checkState(partitionRequestClient != <span class="keyword">null</span>, <span class="string">"Queried for a buffer before requesting a queue."</span>);</span><br><span class="line"></span><br><span class="line">		checkError();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> Buffer next;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">boolean</span> moreAvailable;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">synchronized</span> (receivedBuffers) &#123;</span><br><span class="line">			next = receivedBuffers.poll();</span><br><span class="line">			moreAvailable = !receivedBuffers.isEmpty();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		numBytesIn.inc(next.getSizeUnsafe());</span><br><span class="line">		numBuffersIn.inc();</span><br><span class="line">		<span class="keyword">return</span> Optional.of(<span class="keyword">new</span> BufferAndAvailability(next, moreAvailable, getSenderBacklog()));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>通过ArrayDeque<buffer> 的poll方法，等待通知</buffer></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/28/Flink源码解析-TaskManager启动与运行Task/" rel="next" title="Flink源码解析 TaskManager启动与运行Task">
                <i class="fa fa-chevron-left"></i> Flink源码解析 TaskManager启动与运行Task
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/11/Flink源码解析-Flink-内存基础/" rel="prev" title="Flink源码解析 Flink 内存基础">
                Flink源码解析 Flink 内存基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://note.youdao.com/yws/api/personal/file/85E1A31B078749AAA5FBFA9FF57A0FCB?method=download&shareKey=312d566957926c021bfd2bf29d0fb19c#/images/avatar.gif" alt="笑笑">
            
              <p class="site-author-name" itemprop="name">笑笑</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">134</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据传递"><span class="nav-number">1.</span> <span class="nav-text">数据传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同一线程的Operator数据传递-同一个Task"><span class="nav-number">1.1.</span> <span class="nav-text">同一线程的Operator数据传递(同一个Task)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构建operation-chain"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">构建operation  chain</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同一个线程的Operator中数据的复制"><span class="nav-number">1.1.1.</span> <span class="nav-text">同一个线程的Operator中数据的复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地线程数据传递-同一个TM"><span class="nav-number">1.2.</span> <span class="nav-text">本地线程数据传递(同一个TM)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RecordWriter初始化"><span class="nav-number">1.2.1.</span> <span class="nav-text">RecordWriter初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resultPartitionDeploymentDescriptors怎么来的？"><span class="nav-number">1.2.2.</span> <span class="nav-text">resultPartitionDeploymentDescriptors怎么来的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RecordWriter传递数据"><span class="nav-number">1.2.3.</span> <span class="nav-text">RecordWriter传递数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何从上游中获取buffer"><span class="nav-number">1.2.4.</span> <span class="nav-text">如何从上游中获取buffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程线程数据传递-不同TM"><span class="nav-number">1.3.</span> <span class="nav-text">远程线程数据传递(不同TM)</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">笑笑</span>

  

  
</div>

  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.1</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
